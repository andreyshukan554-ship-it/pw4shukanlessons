{"uuid":"958e2f77-681e-4b97-b1af-0be01e56c968","name":"Get token","historyId":"3a9abf9b692537dcd528a98c89a1d4d3:5bd835b0d6b1d4ada3b9f0db936e82c8","status":"failed","statusDetails":{"message":"TypeError: apiRequestContext.post: Invalid URL","trace":"TypeError: apiRequestContext.post: Invalid URL\n    at D:\\my\\pw4\\tests\\10lessonapi.spec.js:8:33"},"stage":"finished","steps":[{"status":"passed","statusDetails":{},"stage":"finished","steps":[{"status":"passed","statusDetails":{},"stage":"finished","steps":[{"status":"passed","statusDetails":{},"stage":"finished","steps":[],"attachments":[],"parameters":[],"name":"Create request context","start":1759337513294,"uuid":"ad801ba9-6082-4708-93eb-6266fefc289a","stop":1759337513297}],"attachments":[],"parameters":[],"name":"request","start":1759337513291,"uuid":"a6a17872-eeac-402d-8552-bd98c8cc9305","stop":1759337513297}],"attachments":[],"parameters":[],"name":"Before Hooks","start":1759337513284,"uuid":"3c924f56-40cd-4be1-9572-46b394bcf3bc","stop":1759337513297},{"status":"failed","statusDetails":{"message":"TypeError: apiRequestContext.post: Invalid URL","trace":"TypeError: apiRequestContext.post: Invalid URL\n    at D:\\my\\pw4\\tests\\10lessonapi.spec.js:8:33"},"stage":"finished","steps":[],"attachments":[],"parameters":[],"start":1759337513301,"name":"POST \"class URL {\r\n  #context = new URLContext();\r\n  #searchParams;\r\n  #searchParamsModified;\r\n\r\n  static {\r\n    setURLSearchParamsModified = (obj) => {\r\n      // When URLSearchParams changes, we lazily update URL on the next read/write for performance.\r\n      obj.#searchParamsModified = true;\r\n\r\n      // If URL has an existing search, remove it without cascading back to URLSearchParams.\r\n      // Do this to avoid any internal confusion about whether URLSearchParams or URL is up-to-date.\r\n      if (obj.#context.hasSearch) {\r\n        obj.#updateContext(bindingUrl.update(obj.#context.href, updateActions.kSearch, ''));\r\n      }\r\n    };\r\n  }\r\n\r\n  constructor(input, base = undefined, parseSymbol = undefined) {\r\n    markTransferMode(this, false, false);\r\n\r\n    if (arguments.length === 0) {\r\n      throw new ERR_MISSING_ARGS('url');\r\n    }\r\n\r\n    // StringPrototypeToWellFormed is not needed.\r\n    input = `${input}`;\r\n\r\n    if (base !== undefined) {\r\n      base = `${base}`;\r\n    }\r\n\r\n    let href;\r\n    if (arguments.length < 3) {\r\n      href = bindingUrl.parse(input, base, true);\r\n    } else {\r\n      const raiseException = parseSymbol !== kParseURLSymbol;\r\n      const interpretAsWindowsPath = parseSymbol === kCreateURLFromWindowsPathSymbol;\r\n      const pathToFileURL = interpretAsWindowsPath || (parseSymbol === kCreateURLFromPosixPathSymbol);\r\n      href = pathToFileURL ?\r\n        bindingUrl.pathToFileURL(input, interpretAsWindowsPath, base) :\r\n        bindingUrl.parse(input, base, raiseException);\r\n    }\r\n    if (href) {\r\n      this.#updateContext(href);\r\n    }\r\n  }\r\n\r\n  static parse(input, base = undefined) {\r\n    if (arguments.length === 0) {\r\n      throw new ERR_MISSING_ARGS('url');\r\n    }\r\n    const parsedURLObject = new URL(input, base, kParseURLSymbol);\r\n    return parsedURLObject.href ? parsedURLObject : null;\r\n  }\r\n\r\n  [inspect.custom](depth, opts) {\r\n    if (typeof depth === 'number' && depth < 0)\r\n      return this;\r\n\r\n    const constructor = getConstructorOf(this) || URL;\r\n    const obj = { __proto__: { constructor } };\r\n\r\n    obj.href = this.href;\r\n    obj.origin = this.origin;\r\n    obj.protocol = this.protocol;\r\n    obj.username = this.username;\r\n    obj.password = this.password;\r\n    obj.host = this.host;\r\n    obj.hostname = this.hostname;\r\n    obj.port = this.port;\r\n    obj.pathname = this.pathname;\r\n    obj.search = this.search;\r\n    obj.searchParams = this.searchParams;\r\n    obj.hash = this.hash;\r\n\r\n    if (opts.showHidden) {\r\n      obj[contextForInspect] = this.#context;\r\n    }\r\n\r\n    return `${constructor.name} ${inspect(obj, opts)}`;\r\n  }\r\n\r\n  #getSearchFromContext() {\r\n    if (!this.#context.hasSearch) return '';\r\n    let endsAt = this.#context.href.length;\r\n    if (this.#context.hasHash) endsAt = this.#context.hash_start;\r\n    if (endsAt - this.#context.search_start <= 1) return '';\r\n    return StringPrototypeSlice(this.#context.href, this.#context.search_start, endsAt);\r\n  }\r\n\r\n  #getSearchFromParams() {\r\n    if (!this.#searchParams?.size) return '';\r\n    return `?${this.#searchParams}`;\r\n  }\r\n\r\n  #ensureSearchParamsUpdated() {\r\n    // URL is updated lazily to greatly improve performance when URLSearchParams is updated repeatedly.\r\n    // If URLSearchParams has been modified, reflect that back into URL, without cascading back.\r\n    if (this.#searchParamsModified) {\r\n      this.#searchParamsModified = false;\r\n      this.#updateContext(bindingUrl.update(this.#context.href, updateActions.kSearch, this.#getSearchFromParams()));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update the internal context state for URL.\r\n   * @param {string} href New href string from `bindingUrl.update`.\r\n   * @param {boolean} [shouldUpdateSearchParams] If the update has potential to update search params (href/search).\r\n   */\r\n  #updateContext(href, shouldUpdateSearchParams = false) {\r\n    const previousSearch = shouldUpdateSearchParams && this.#searchParams &&\r\n      (this.#searchParamsModified ? this.#getSearchFromParams() : this.#getSearchFromContext());\r\n\r\n    this.#context.href = href;\r\n\r\n    const {\r\n      0: protocol_end,\r\n      1: username_end,\r\n      2: host_start,\r\n      3: host_end,\r\n      4: port,\r\n      5: pathname_start,\r\n      6: search_start,\r\n      7: hash_start,\r\n      8: scheme_type,\r\n    } = bindingUrl.urlComponents;\r\n\r\n    this.#context.protocol_end = protocol_end;\r\n    this.#context.username_end = username_end;\r\n    this.#context.host_start = host_start;\r\n    this.#context.host_end = host_end;\r\n    this.#context.port = port;\r\n    this.#context.pathname_start = pathname_start;\r\n    this.#context.search_start = search_start;\r\n    this.#context.hash_start = hash_start;\r\n    this.#context.scheme_type = scheme_type;\r\n\r\n    if (this.#searchParams) {\r\n      // If the search string has updated, URL becomes the source of truth, and we update URLSearchParams.\r\n      // Only do this when we're expecting it to have changed, otherwise a change to hash etc.\r\n      // would incorrectly compare the URLSearchParams state to the empty URL search state.\r\n      if (shouldUpdateSearchParams) {\r\n        const currentSearch = this.#getSearchFromContext();\r\n        if (previousSearch !== currentSearch) {\r\n          setURLSearchParams(this.#searchParams, currentSearch);\r\n          this.#searchParamsModified = false;\r\n        }\r\n      }\r\n\r\n      // If we have a URLSearchParams, ensure that URL is up-to-date with any modification to it.\r\n      this.#ensureSearchParamsUpdated();\r\n    }\r\n  }\r\n\r\n  toString() {\r\n    // Updates to URLSearchParams are lazily propagated to URL, so we need to check we're in sync.\r\n    this.#ensureSearchParamsUpdated();\r\n    return this.#context.href;\r\n  }\r\n\r\n  get href() {\r\n    // Updates to URLSearchParams are lazily propagated to URL, so we need to check we're in sync.\r\n    this.#ensureSearchParamsUpdated();\r\n    return this.#context.href;\r\n  }\r\n\r\n  set href(value) {\r\n    value = `${value}`;\r\n    const href = bindingUrl.update(this.#context.href, updateActions.kHref, value);\r\n    if (!href) { throw new ERR_INVALID_URL(value); }\r\n    this.#updateContext(href, true);\r\n  }\r\n\r\n  // readonly\r\n  get origin() {\r\n    const protocol = StringPrototypeSlice(this.#context.href, 0, this.#context.protocol_end);\r\n\r\n    // Check if scheme_type is not `NOT_SPECIAL`\r\n    if (this.#context.scheme_type !== 1) {\r\n      // Check if scheme_type is `FILE`\r\n      if (this.#context.scheme_type === 6) {\r\n        return 'null';\r\n      }\r\n      return `${protocol}//${this.host}`;\r\n    }\r\n\r\n    if (protocol === 'blob:') {\r\n      const path = this.pathname;\r\n      if (path.length > 0) {\r\n        try {\r\n          const out = new URL(path);\r\n          // Only return origin of scheme is `http` or `https`\r\n          // Otherwise return a new opaque origin (null).\r\n          if (out.#context.scheme_type === 0 || out.#context.scheme_type === 2) {\r\n            return `${out.protocol}//${out.host}`;\r\n          }\r\n        } catch {\r\n          // Do nothing.\r\n        }\r\n      }\r\n    }\r\n\r\n    return 'null';\r\n  }\r\n\r\n  get protocol() {\r\n    return StringPrototypeSlice(this.#context.href, 0, this.#context.protocol_end);\r\n  }\r\n\r\n  set protocol(value) {\r\n    const href = bindingUrl.update(this.#context.href, updateActions.kProtocol, `${value}`);\r\n    if (href) {\r\n      this.#updateContext(href);\r\n    }\r\n  }\r\n\r\n  get username() {\r\n    if (this.#context.protocol_end + 2 < this.#context.username_end) {\r\n      return StringPrototypeSlice(this.#context.href, this.#context.protocol_end + 2, this.#context.username_end);\r\n    }\r\n    return '';\r\n  }\r\n\r\n  set username(value) {\r\n    const href = bindingUrl.update(this.#context.href, updateActions.kUsername, `${value}`);\r\n    if (href) {\r\n      this.#updateContext(href);\r\n    }\r\n  }\r\n\r\n  get password() {\r\n    if (this.#context.host_start - this.#context.username_end > 0) {\r\n      return StringPrototypeSlice(this.#context.href, this.#context.username_end + 1, this.#context.host_start);\r\n    }\r\n    return '';\r\n  }\r\n\r\n  set password(value) {\r\n    const href = bindingUrl.update(this.#context.href, updateActions.kPassword, `${value}`);\r\n    if (href) {\r\n      this.#updateContext(href);\r\n    }\r\n  }\r\n\r\n  get host() {\r\n    let startsAt = this.#context.host_start;\r\n    if (this.#context.href[startsAt] === '@') {\r\n      startsAt++;\r\n    }\r\n    // If we have an empty host, then the space between components.host_end and\r\n    // components.pathname_start may be occupied by /.\r\n    if (startsAt === this.#context.host_end) {\r\n      return '';\r\n    }\r\n    return StringPrototypeSlice(this.#context.href, startsAt, this.#context.pathname_start);\r\n  }\r\n\r\n  set host(value) {\r\n    const href = bindingUrl.update(this.#context.href, updateActions.kHost, `${value}`);\r\n    if (href) {\r\n      this.#updateContext(href);\r\n    }\r\n  }\r\n\r\n  get hostname() {\r\n    let startsAt = this.#context.host_start;\r\n    // host_start might be \"@\" if the URL has credentials\r\n    if (this.#context.href[startsAt] === '@') {\r\n      startsAt++;\r\n    }\r\n    return StringPrototypeSlice(this.#context.href, startsAt, this.#context.host_end);\r\n  }\r\n\r\n  set hostname(value) {\r\n    const href = bindingUrl.update(this.#context.href, updateActions.kHostname, `${value}`);\r\n    if (href) {\r\n      this.#updateContext(href);\r\n    }\r\n  }\r\n\r\n  get port() {\r\n    if (this.#context.hasPort) {\r\n      return `${this.#context.port}`;\r\n    }\r\n    return '';\r\n  }\r\n\r\n  set port(value) {\r\n    const href = bindingUrl.update(this.#context.href, updateActions.kPort, `${value}`);\r\n    if (href) {\r\n      this.#updateContext(href);\r\n    }\r\n  }\r\n\r\n  get pathname() {\r\n    let endsAt;\r\n    if (this.#context.hasSearch) {\r\n      endsAt = this.#context.search_start;\r\n    } else if (this.#context.hasHash) {\r\n      endsAt = this.#context.hash_start;\r\n    }\r\n    return StringPrototypeSlice(this.#context.href, this.#context.pathname_start, endsAt);\r\n  }\r\n\r\n  set pathname(value) {\r\n    const href = bindingUrl.update(this.#context.href, updateActions.kPathname, `${value}`);\r\n    if (href) {\r\n      this.#updateContext(href);\r\n    }\r\n  }\r\n\r\n  get search() {\r\n    // Updates to URLSearchParams are lazily propagated to URL, so we need to check we're in sync.\r\n    this.#ensureSearchParamsUpdated();\r\n    return this.#getSearchFromContext();\r\n  }\r\n\r\n  set search(value) {\r\n    const href = bindingUrl.update(this.#context.href, updateActions.kSearch, StringPrototypeToWellFormed(`${value}`));\r\n    if (href) {\r\n      this.#updateContext(href, true);\r\n    }\r\n  }\r\n\r\n  // readonly\r\n  get searchParams() {\r\n    // Create URLSearchParams on demand to greatly improve the URL performance.\r\n    if (this.#searchParams == null) {\r\n      this.#searchParams = new URLSearchParams(this.#getSearchFromContext());\r\n      setURLSearchParamsContext(this.#searchParams, this);\r\n      this.#searchParamsModified = false;\r\n    }\r\n    return this.#searchParams;\r\n  }\r\n\r\n  get hash() {\r\n    if (!this.#context.hasHash || (this.#context.href.length - this.#context.hash_start <= 1)) {\r\n      return '';\r\n    }\r\n    return StringPrototypeSlice(this.#context.href, this.#context.hash_start);\r\n  }\r\n\r\n  set hash(value) {\r\n    const href = bindingUrl.update(this.#context.href, updateActions.kHash, `${value}`);\r\n    if (href) {\r\n      this.#updateContext(href);\r\n    }\r\n  }\r\n\r\n  toJSON() {\r\n    // Updates to URLSearchParams are lazily propagated to URL, so we need to check we're in sync.\r\n    this.#ensureSearchParamsUpdated();\r\n    return this.#context.href;\r\n  }\r\n\r\n  static canParse(url, base = undefined) {\r\n    if (arguments.length === 0) {\r\n      throw new ERR_MISSING_ARGS('url');\r\n    }\r\n\r\n    url = `${url}`;\r\n\r\n    if (base !== undefined) {\r\n      return bindingUrl.canParse(url, `${base}`);\r\n    }\r\n\r\n    // It is important to differentiate the canParse call statements\r\n    // since they resolve into different v8 fast api overloads.\r\n    return bindingUrl.canParse(url);\r\n  }\r\n}/challenger\"","uuid":"f7f0f17b-040a-4fdd-a5be-f375d1c2c3b0","stop":1759337513305},{"status":"passed","statusDetails":{},"stage":"finished","steps":[{"status":"passed","statusDetails":{},"stage":"finished","steps":[],"attachments":[],"parameters":[],"name":"request","start":1759337513307,"uuid":"2bf02c5e-d5af-4ac8-896f-b7b73488a32b","stop":1759337513309}],"attachments":[],"parameters":[],"name":"After Hooks","start":1759337513306,"uuid":"d39ac30c-e648-4680-8d7f-60d7a4b55adf","stop":1759337513310}],"attachments":[{"name":"stdout","source":"f831e05d-1e3a-4389-b9e9-ed51a3c9b99b-attachment.txt","type":"text/plain"}],"parameters":[{"name":"Project","value":"chromium"}],"labels":[{"name":"language","value":"javascript"},{"name":"framework","value":"playwright"},{"name":"package","value":"10lessonapi.spec.js"},{"name":"titlePath","value":" > chromium > 10lessonapi.spec.js > Challenge"},{"name":"host","value":"NBOOK146"},{"name":"thread","value":"pid-11220-worker-0"},{"name":"parentSuite","value":"chromium"},{"name":"suite","value":"10lessonapi.spec.js"},{"name":"subSuite","value":"Challenge"}],"links":[],"start":1759337513291,"testCaseId":"3a9abf9b692537dcd528a98c89a1d4d3","fullName":"10lessonapi.spec.js:6:10","titlePath":["10lessonapi.spec.js","Challenge"],"stop":1759337513311}